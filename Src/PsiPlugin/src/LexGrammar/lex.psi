options
{
  parserPackage="JetBrains.ReSharper.PsiPlugin.Psi.Lex.Parsing";
  parserClassName="LexParserGenerated";
  psiInterfacePackageName="JetBrains.ReSharper.PsiPlugin.Psi.Lex.Tree";
  psiStubsPackageName="JetBrains.ReSharper.PsiPlugin.Psi.Lex.Tree.Impl";
  psiStubsBaseClass="LexCompositeElement";
  tokenTypePrefix="";
  parserTargetSubdir="Parsing/Lex";
  psiInterfacesTargetSubdir="Psi/Lex/Tree";
  psiStubsTargetSubdir="Psi/Lex/Tree/Impl";
  elementTypePrefix="";
  visitorClassName="TreeNodeVisitor";
  visitorMethodSuffix="";
  testTargetSubdir="Psi/Test/Lex";
  disableReflection;
  separateHierarchies;
  "treeElementClassFQName"="JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement";
  "compositeElementClassFQName"="LexCompositeElement";
  "psiElementVisitorClassFQName"="JetBrains.ReSharper.PsiPlugin.Psi.Lex.Tree.TreeNodeVisitor";
  "tokenTypeClassFQName"="JetBrains.ReSharper.PsiPlugin.Psi.Lex.Parsing.LexTokenType";
  "visitMethodPrefix"="Visit";
  "lexerClassName"="JetBrains.ReSharper.Psi.Parsing.ILexer";
  "psiClassesPrefix"="";
  "psiElementClassFQName"="JetBrains.ReSharper.PsiPlugin.Psi.Lex.Tree.ILexTreeNode";
  customImplPackage="JetBrains.ReSharper.PsiPlugin.Psi.Lex.Tree.Impl";
  customInterfacePackage="JetBrains.ReSharper.PsiPlugin.Psi.Lex.Tree";
  "interfaceNamePrefix"="I";
  "tokenElementClassFQName"="JetBrains.ReSharper.Psi.Tree.ITokenNode";
  "customImplSuffix"="";
  "objectClassFQName"="System.Object";
  tokenBitsetThreshold=4;
  elementTypeBaseClass="JetBrains.ReSharper.PsiPlugin.Psi.Lex.Tree.LexCompositeNodeType";
  parserMessagesClass="JetBrains.ReSharper.PsiPlugin.Psi.Lex.Parsing.ParserMessages";
  generateWorkingPsi;
}

errorhandling lexFile
options
{
  stubBase="LexFileElement";
}
  :
    usingList
    definitionBlock
    lexingBlock
  ;

usingList
  :
    //todo
    IDENTIFIER
  ;

definitionBlock
  :
    encodingDefinition
    initBlock
    braceBlock?
    lexerOptions
    declarationOrInclude
  ;

encodingDefinition
  :
//todo
    IDENTIFIER
  ;

initBlock
  :
//todo
    IDENTIFIER
  ;

braceBlock
  :
//todo
    IDENTIFIER
  ;

lexerOptions
  :
//todo
    IDENTIFIER
  ;

declarationOrInclude
  :
    (tokenDeclaration | includeStatement)*
  ;

tokenDeclaration
  :
    tokenDeclaredName
    EQ
    lexingExpression
  ;

tokenDeclaredName
  :
    IDENTIFIER
  ;

char
  :
    BACK_SLASH
    (charId | specialChar)
  ;

specialChar
  :
    (BACK_SLASH | BACK_QUOTE | AT)
  ;

charId
  :
    IDENTIFIER
  ;

lexingExpression
  :
    char
    | sequence
    | parenExpreession
  ;

sequence
  :
    simpleExpression+
  ;

simpleExpression
  :
    (qualified | STRING_LITERAL | INTEGER_LITERAL | tokenTypeUsage | parenExpreession | regexp)
  ;

qualified
  :
    (STRING_LITERAL | tokenTypeUsage | parenExpreession | regexp)
    qualifier
  ;

qualifier
  :
    ASTERISK
    | QUEST
    | PLUS
  ;

tokenTypeUsage
  :
    LBRACE
    tokenTypeName
    RBRACE
  ;

parenExpreession
  :
    LPARENTH
    choiceExpression
    RPARENTH
  ;

choiceExpression
  :
    lexingExpression
    (OR lexingExpression)*
  ;

regexp
  :
    LBRACKET
    regexpBody
    RBRACKET
  ;

regexpBody
  :
	//todo
    IDENTIFIER
  ;

includeStatement
  :
    PERC
    INCLUDE_KEYWORD
    pathId
  ;

pathId
  :
    (folder DIV)*
    file
  ;

folder
  :
    (IDENTIFIER | DOT DOT| DOT) 
  ;

file
  :
    fileName
    DOT
    fileExt
  ;

fileName
  :
    IDENTIFIER
  ;

fileExt
  :
    IDENTIFIER
  ;

lexingBlock
  :
    makeTokenBlock*
  ;

makeTokenBlock
  :
    state
    ( LBRACE tokenTypeName RBRACE | STRING_LITERAL)
    LBRACE
    cSharpBlock
    RBRACE    
  ;

state
  :
    LT
    stateName
    GT
  ;

stateName
  :
    IDENTIFIER
  ;

tokenTypeName
  :
    IDENTIFIER
  ;

cSharpBlock
  :
	//todo
    IDENTIFIER
  ;
