options
{
  parserPackage="JetBrains.ReSharper.PsiPlugin.Psi.Lex.Parsing";
  parserClassName="LexParserGenerated";
  psiInterfacePackageName="JetBrains.ReSharper.PsiPlugin.Psi.Lex.Tree";
  psiStubsPackageName="JetBrains.ReSharper.PsiPlugin.Psi.Lex.Tree.Impl";
  psiStubsBaseClass="LexCompositeElement";
  tokenTypePrefix="";
  parserTargetSubdir="Parsing/Lex";
  psiInterfacesTargetSubdir="Psi/Lex/Tree";
  psiStubsTargetSubdir="Psi/Lex/Tree/Impl";
  elementTypePrefix="";
  visitorClassName="TreeNodeVisitor";
  visitorMethodSuffix="";
  testTargetSubdir="Psi/Test/Lex";
  disableReflection;
  separateHierarchies;
  "treeElementClassFQName"="JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement";
  "compositeElementClassFQName"="LexCompositeElement";
  "psiElementVisitorClassFQName"="JetBrains.ReSharper.PsiPlugin.Psi.Lex.Tree.TreeNodeVisitor";
  "tokenTypeClassFQName"="JetBrains.ReSharper.PsiPlugin.Psi.Lex.Parsing.LexTokenType";
  "visitMethodPrefix"="Visit";
  "lexerClassName"="JetBrains.ReSharper.Psi.Parsing.ILexer";
  "psiClassesPrefix"="";
  "psiElementClassFQName"="JetBrains.ReSharper.PsiPlugin.Psi.Lex.Tree.ILexTreeNode";
  customImplPackage="JetBrains.ReSharper.PsiPlugin.Psi.Lex.Tree.Impl";
  customInterfacePackage="JetBrains.ReSharper.PsiPlugin.Psi.Lex.Tree";
  "interfaceNamePrefix"="I";
  "tokenElementClassFQName"="JetBrains.ReSharper.Psi.Tree.ITokenNode";
  "customImplSuffix"="";
  "objectClassFQName"="System.Object";
  tokenBitsetThreshold=4;
  elementTypeBaseClass="JetBrains.ReSharper.PsiPlugin.Psi.Lex.Tree.LexCompositeNodeType";
  parserMessagesClass="JetBrains.ReSharper.PsiPlugin.Psi.Lex.Parsing.ParserMessages";
  generateWorkingPsi;
}

errorhandling lexFile
options
{
  stubBase="LexFileElement";
}
  :
    usingList
    definitionBlock
    lexingBlock
  ;

errorhandling usingList
  :
    usingItem*
  ;

errorhandling usingItem
  :
    USING_KEYWORD
    cSharpNamespace
    SEMICOLON
  ;

cSharpNamespace
  :
    cSharpNamespaceName
    (DOT cSharpNamespaceName)*
  ;

cSharpNamespaceName
  :
    IDENTIFIER
  ;

errorhandling definitionBlock
  :
    PERCPERC
    encodingDefinition
    initBlock
    braceBlock?
    lexerOptionsBlock
    declarationOrInclude
    PERCPERC
  ;

encodingDefinition
  :
    PERC
    IDENTIFIER
  ;

initBlock
  :
	PERC
	INIT_KEYWORD
	LBRACE
	cSharpBlock
	PERC
	INIT_KEYWORD
	RBRACE
  ;

braceBlock
  :
    PERC
    LBRACE
    PERC
    RBRACE
  ;

lexerOptionsBlock
  :
	lexerOption*
  ;

errorhandling lexerOption
  :
    PERC
    (namespaceLexerOption
    | classLexerOption
    | classModifierLexerOption
    | implementsLexerOption
    | functionLexerOption
    | functionModifierLexerOption
    | typeLexerOption
    | eofvalLexerOption)
  ;

namespaceLexerOption
  :
    NAMESPACE_KEYWORD
    cSharpNamespace
  ;

classLexerOption
  :
    CLASS_KEYWORD
    cSharpClassName
  ;

classModifierLexerOption
  :
    PUBLIC_KEYWORD
  ;

implementsLexerOption
  :
    IMPLEMENTS_KEYWORD
    cSharpClassName
  ;

functionLexerOption
  :
    FUNCTION_KEYWORD
    functionName
  ;

functionName
  :
    IDENTIFIER
  ;

functionModifierLexerOption
  :
    VIRTUAL_KEYWORD
  ;

typeLexerOption
  :
    TYPE_KEYWORD
    cSharpClassName
  ;

cSharpClassName
  :
    IDENTIFIER
  ;

eofvalLexerOption
  :
    EOFVAL_KEYWORD
    LBRACE
    cSharpBlock
    PERC
    EOFVAL_KEYWORD
    RBRACE
  ;

errorhandling declarationOrInclude
  :
    (tokenDeclaration | includeStatement)*
  ;

errorhandling tokenDeclaration
  :
    tokenDeclaredName
    EQ
    firstLexingExpression
  ;

firstLexingExpression
  :
    (
      firstLexingExpressionItem
    )
    (
      OR
      firstLexingExpressionItem
    )*
  ;

firstLexingExpressionItem
  :
    parenExpression
      | char
      | simpleSequence
      | regexp
      | QUOTE
      | BACK_SLASH
      | DOUBLE_QUOTE
  ;

simpleSequence
  :
    ((tokenTypeUsage | STRING_LITERAL | parenExpression | QUOTE | BACK_SLASH | BACK_QUOTE) qualifier?)*
  ;

tokenDeclaredName
  :
    IDENTIFIER
  ;

char
  :
    BACK_SLASH 
    specialChar
    | unicodeChar
  ;

unicodeChar
  :
    IDENTIFIER
  ;

specialChar
  :
    (BACK_SLASH | BACK_QUOTE | AT | QUOTE | SHARP | DIV | DOUBLE_QUOTE)
  ;

charId
  :
    IDENTIFIER
  ;

lexingExpression
  :
    sequence choiceTail*
  ;

choiceTail
  :
    OR
    sequence
  ;

sequence
  :
    simpleExpression+
  ;

simpleExpression
  :
    (STRING_LITERAL | INTEGER_LITERAL | tokenTypeUsage | parenExpression | regexp | IDENTIFIER | quotedChar | BACK_SLASH | QUOTE | DOUBLE_QUOTE | AT)
    qualifier?
  ;

qualifier
  :
    ASTERISK
    | QUEST
    | PLUS
  ;

tokenTypeUsage
  :
    LBRACE
    tokenTypeName
    RBRACE
  ;

parenExpression
  :
    LPARENTH
    lexingExpression
    RPARENTH
  ;

regexp
  :
    LBRACKET
    regexpBody
    RBRACKET
  ;

regexpBody
  :
    basic_reg_exp
  ;

//http://pubs.opengroup.org/onlinepubs/007908799/xbd/re.html
/* --------------------------------------------
   Basic Regular Expression
   --------------------------------------------
*/
basic_reg_exp
  :
    RE_expression DOLLAR?
    | XOR RE_expression? DOLLAR?
    | DOLLAR
  ;
RE_expression
  :
    simple_RE*
  ;
simple_RE
  :
    nondupl_RE+
    //RE_dupl_symbol?
  ;
nondupl_RE
  :
    (
      SIMPLE_BACK_SLASH
      (
        LPARENTH
        RE_expression
        BACK_SLASH
        RPARENTH
        | LPARENTH
          BACK_SLASH
          RPARENTH
        | INTEGER_LITERAL
        | specialChar
        | IDENTIFIER
      )?
      | regexpList
      | RPARENTH
      | BACK_SLASH
      | QUOTE
      | DOUBLE_QUOTE
      | SHARP
    )
  ;

regexpList
  :
    regexpListItem*
  ;

backRef
  :
    BACK_SLASH
    INTEGER_LITERAL
  ;

errorhandling regexpListItem
  :
//ORD_CHAR
    quotedChar
    | DOT
    | PLUS
    | MINUS
    | bracket_expression
    | interval
    | digitInterval
  ;

digitInterval
  :
    INTEGER_LITERAL
    (
      MINUS
      INTEGER_LITERAL
    )*
  ;

interval
  :
    IDENTIFIER
    (
      MINUS
      IDENTIFIER
    )*
  ;

quotedChar
  :
    SIMPLE_BACK_SLASH
    (
      XOR
      | DOT
      | ASTERISK
      | DOLLAR
      | SHARP
      | DIV
      | AT
      | IDENTIFIER
    )
  ;

RE_dupl_symbol
  :
    ASTERISK
    | BACK_SLASH
    LBRACE
    INTEGER_LITERAL
    BACK_SLASH
    RBRACE
    | BACK_SLASH
    LBRACE
    INTEGER_LITERAL
    COMMA
    BACK_SLASH
    RBRACE
    | BACK_SLASH
    LBRACE
    INTEGER_LITERAL
    COMMA
    INTEGER_LITERAL
    BACK_SLASH
    RBRACE
  ;

/* --------------------------------------------
   Bracket Expression
   -------------------------------------------
*/
bracket_expression
  :
    LBRACKET
    matching_list
    RBRACKET
    | LBRACKET
    nonmatching_list
    RBRACKET
  ;
matching_list
  :
    bracket_list
  ;
nonmatching_list
  :
    XOR
    bracket_list
  ;
bracket_list
  :
    follow_list
    | follow_list
    MINUS
  ;
follow_list
  :
    expression_term
    | follow_list
    expression_term
  ;
expression_term
  :
    single_expression
    | range_expression
  ;
single_expression
  :
    end_range
    | character_class
    | equivalence_class
  ;
range_expression
  :
    start_range
    end_range
    | start_range
    MINUS
  ;
start_range
  :
    end_range
    MINUS
  ;
end_range
  :
    coll_elem
    collating_symbol
  ;

coll_elem
  :
//todo
    IDENTIFIER
  ;
collating_symbol
  :
    LBRACKET DOT
    coll_elem
    DOT RBRACKET
    | LBRACKET DOT
    meta_char
    DOT RBRACKET
  ;

meta_char
  :
//todo
    IDENTIFIER
  ;
equivalence_class
  :
    LBRACKET EQ
    coll_elem
    EQ RBRACKET
  ;
character_class
  :
    LBRACKET COLON
    regExpClass
    COLON RBRACKET
  ;

regExpClass
  :
    IDENTIFIER
  ;

///////////////////////////////////////////////////

errorhandling includeStatement
  :
    PERC
    INCLUDE_KEYWORD
    pathId
  ;

pathId
  :
    (pathElement)
    (DIV pathElement)*
    DOT
    fileExt
  ;

pathElement
  :
    (DOT DOT | DOT | IDENTIFIER)
  ;


fileExt
  :
    IDENTIFIER
  ;

errorhandling lexingBlock
  :
    makeTokenBlock*
  ;

makeTokenBlock
  :
    state
    ( LBRACE tokenTypeName RBRACE | STRING_LITERAL)
    LBRACE
    cSharpBlock
    RBRACE    
  ;

state
  :
    LT
    stateName
    GT
  ;

stateName
  :
    IDENTIFIER
  ;

tokenTypeName
  :
    IDENTIFIER
  ;

errorhandling cSharpBlock
  :
//todo
    IDENTIFIER
  ;
